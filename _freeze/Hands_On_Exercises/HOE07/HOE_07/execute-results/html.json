{
  "hash": "9895623cabd870676345b0ab1bb2d42e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands on Exercise 07: Visualising and Analysing Time-Oriented Data\"\nauthor: \"Yee Jun Yit\"\ndate-modified: \"last-modified\"\nexecute:\n  echo: true\n  eval: true\n  warning: false\n  freeze: true\n---\n\n\n\n## Overview\n\nIn this exercise, we will learn how to use R packages to create the following data visualisations:\n\n(1) plot a calender heatmap by using **ggplot2** functions,\n(2) plot a cycle plot by using ggplot2 function,\n(3) plot a slopegraph,\n(4) plot a horizon chart\n\n## Loading Data\n\nWe will be using the following packages:\n\n-  [**scales**](https://scales.r-lib.org/) provides the internal scaling infrastructure used by **ggplot2**, and provides tools to override the default breaks, labels, transformations and palettes;\n-  [**viridis**](https://r-graph-gallery.com/package/viridis.html) enhances data visualization by offering a collection of color maps that are perceptually uniform in color and brightness;\n-  [**gridExtra**](https://cran.r-project.org/web/packages/gridExtra/gridExtra.pdf) provides a number of user-level functions to work with \"grid\" graphics, notably to arrange multiple grid-based plots on a page, and draw tables;\n-  [**knitr**](https://yihui.org/knitr/), a transparent engine for dynamic report generation with R;\n-  [**data.table**](https://cran.r-project.org/web/packages/data.table/data.table.pdf), an extension of **data.frame** that offers fast aggregation of large data ;\n-  [**lubridate**](https://lubridate.tidyverse.org/), part of **tidyverse**, makes it easier to do the things R does with date-times and possible to do the things R does not;\n-  tidyverse, a family of R packages for data science processes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(readxl, scales, viridis, gridExtra, knitr, data.table, lubridate, tidyverse, ggthemes)\n```\n:::\n\n\n\nIn this exercise, we will be using *eventlog.csv*, which contains time-series cyber attack records by country across 199,999 rows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"data/eventlog.csv\")\n```\n:::\n\n\n\n### Examining the Data\nTo examine the imported data frame before further analysis is performed, we will use [`kable()`](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html) function from **knitr** package, which is a simple table generator to view the structure of the imported data.frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n\n\n:::\n:::\n\n\nThere are three columns, namely *timestamp*, *source_country* and *tz*.\n\n-  The *timestamp* field stores date-time values in POSIXct format. This format stores both a date and time with an associated time zone in terms of seconds since 1 January 1970\n-  The *source_country* field stores the source of the attack. It is formatted in ISO 3166-1 alpha-2 country code.\n-  The *tz* field stores time zone of the source IP address.\n\n## Plotting Calendar Heatmaps\n\nIn this section, we will plot a calender heatmap by using **ggplot2** package. We will do this by\n\n(1)  preparing the data by using tidyr and dplyr packages;\n(2)  deriving the specific date and time related field by using base R and **lubridate** packages;\n(3)  write functions using R programming.\n\n### Data Preparation\n\nStep 1: Deriving *weekday* and *hour of day* fields\n\nBefore we can plot the calender heatmap, two new fields namely *wkday* and *hour* need to be derived. In this step, we will write a function to perform the task.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  \n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n\n::: {.callout-note}\n#### Note\n\n-  [ymd_hms()](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [hour()](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and\n-  [weekdays()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a base R function.\n:::\n\nStep 2: Deriving the attacks tibble data frame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n\n::: {.callout-note}\n#### Note\nWe first group the attacks dataset by *tz* (time zone), pass the *timestamp*, *source_country*, and *tz* columns from each group into the `make_hr_wkday()` function to be converted into weekday and hour components, then ungroup the data to return to a data.table.\n\nBesides extracting the necessary data into the *attacks* data.frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into factor so they’ll be ordered when plotting.\n:::\n\nThe table below shows tidy tibble table after processing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n\n\n:::\n:::\n\n\n### Build the Calendar Heatmap\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          linewidth = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](HOE_07_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip}\n#### Things to learn from the code chunk above\n\n-  a tibble data.table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.\n-  a new field called *n* is derived by using `group_by()` the `count()` function, inside of which uses `group_by()` to create *n*.\n-  `na.omit()` is used to exclude missing value.\n-  We can then plot the calendar heatmap. Since we know that we have values for every combination, there’s no need to further preprocess the data.\n-  `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.\n-  [**theme_tufte()**](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/index.html) package is used to remove unnecessary chart junk (borders,axis lines, grids).\n-  `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n-  `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\n### Building Multiple Calendar Heatmaps: `facet_wrap()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_countries <- attacks %>%\n  count(source_country) %>% \n  top_n(4, wt = n) %>% \n  pull(source_country)\n\ngrouped <- attacks %>% \n  filter(source_country %in% top_countries) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, aes(hour, wkday, fill = n)) + \n  geom_tile(color = \"white\", size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                      low = \"sky blue\", \n                      high = \"dark blue\") +\n  labs(x = NULL, \n       y = NULL, \n       title = \"Attacks by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6)) +\n  facet_wrap(~source_country)  \n```\n\n::: {.cell-output-display}\n![](HOE_07_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip}\n#### Things to learn from the code chunk above\n\nWe made a few additions to the code in order to build the visualisation above\n-  We first identify the top 4 countries with the most attacks using `top_n()` function, where argument *wt* is the column we rank by, and use `pull()` function of **dplyr** package to extract the country names as a vector of values *top_countries*,\n-  We filter the data to keep only attacks from the top 4 countries,\n-  We do the data processing and plot as usual,\n-  We then use `facet_wrap()` of **ggplot2** package to create separate heatmaps for each of the top 4 countries, arranged in a grid.\n:::\n\n### Building Multiple Calendar Heatmaps: Alternative\n\nStep 1: Deriving attack by country object\n\nIn order to identify the top 4 countries with the highest number of attacks, we do the following:\n\n-  count the number of attacks by country,\n-  calculate the percent of attackes by country, and\n-  save the results in a tibble data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n\nStep 2: Prepare the tibble data.frame\n\nIn this step, we extract the attack records of the top 4 countries from attacks data frame and save the data in a new tibble data frame (i.e. top4_attacks).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n\nStep 3: Plot the Multiple Calender Heatmap by using ggplot2 package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](HOE_07_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n## Plotting Cycle Plots\n\nIn this section, we will plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.\n\n### Import Data\n\nFor the purpose of this exercise, we will use *arrivals_by_air.xlsx*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n\nIt contains monthly time series data where each column is a country containing the number of arrivals from that country in that particular month.\n\n### Deriving month and year fields\n\nWe need to derive two new fields called *month* and *year* from the *Month-Year* field\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n\n`months.abb` is a built-in character vector that contains the 3 letter abbreviations of the 12 months of the year\n\n### Extract the target country (Vietnam)\n\nWe only look at data starting from Year 2010\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\n\n### Compute year average arrivals by month\n\nWe use `group_by()` and `summarise()` of **dplyr** to compute year average arrivals by month.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n\n### Plot the Cycle Plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_gray(base_family = \"Helvetica\")\n```\n\n::: {.cell-output-display}\n![](HOE_07_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n## Plotting Slopegraph\n\nIn this section we will plot a [slopegraph](https://www.storytellingwithdata.com/blog/2020/7/27/what-is-a-slopegraph) by using R.\n\nWe will require the [**CGPfunctions**](https://cran.r-project.org/web/packages/CGPfunctions/CGPfunctions.pdf) package, which has a function [newggslopegraph](https://cran.r-project.org/web/packages/CGPfunctions/vignettes/Using-newggslopegraph.html) to automate the process of producing a slopegraph using **ggplot2**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(CGPfunctions)\n```\n:::\n\n\n\n### Import Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"data/rice.csv\")\n```\n:::\n\n\n### Plot the slopegraph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Yee Jun Yit\")\n```\n\n::: {.cell-output-display}\n![](HOE_07_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "HOE_07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}